Практическое задание по теме “Операторы, фильтрация, сортировка и ограничение”

1. Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.

Создам таблицу:

DROP TABLE IF EXISTS users;
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Покупатели';

Вставлю данные:

INSERT INTO users (name, birthday_at) VALUES
  ('Геннадий', '1990-10-05'),
  ('Наталья', '1984-11-12'),
  ('Александр', '1985-05-20'),
  ('Сергей', '1988-02-14'),
  ('Иван', '1998-01-12'),
  ('Мария', '1992-08-29');
  
Обнулю поля created_at и updated_at

> update users set created_at = null, updated_at = null
Query OK, 6 rows affected
Time: 0.013s
> select * from users
+------+-----------+---------------+--------------+--------------+
|   id | name      | birthday_at   |   created_at |   updated_at |
|------+-----------+---------------+--------------+--------------|
|    1 | Геннадий  | 1990-10-05    |       <null> |       <null> |
|    2 | Наталья   | 1984-11-12    |       <null> |       <null> |
|    3 | Александр | 1985-05-20    |       <null> |       <null> |
|    4 | Сергей    | 1988-02-14    |       <null> |       <null> |
|    5 | Иван      | 1998-01-12    |       <null> |       <null> |
|    6 | Мария     | 1992-08-29    |       <null> |       <null> |
+------+-----------+---------------+--------------+--------------+
6 rows in set
Time: 0.002s

Проставлю текущую дату для поля created_at, так где она отсутствует 
update users set created_at = CURRENT_TIMESTAMP where created_at is NULL

Аналогично с updated_at
update users set updated_at = CURRENT_TIMESTAMP where updated_at is NULL

Проверка, что данные заполнились
> select * from users
+------+-----------+---------------+---------------------+---------------------+
|   id | name      | birthday_at   | created_at          | updated_at          |
|------+-----------+---------------+---------------------+---------------------|
|    1 | Геннадий  | 1990-10-05    | 2019-09-22 13:14:06 | 2019-09-22 13:14:06 |
|    2 | Наталья   | 1984-11-12    | 2019-09-22 13:14:06 | 2019-09-22 13:14:06 |
|    3 | Александр | 1985-05-20    | 2019-09-22 13:14:06 | 2019-09-22 13:14:06 |
|    4 | Сергей    | 1988-02-14    | 2019-09-22 13:14:06 | 2019-09-22 13:14:06 |
|    5 | Иван      | 1998-01-12    | 2019-09-22 13:14:06 | 2019-09-22 13:14:06 |
|    6 | Мария     | 1992-08-29    | 2019-09-22 13:14:06 | 2019-09-22 13:14:06 |
+------+-----------+---------------+---------------------+---------------------+
6 rows in set
Time: 0.002s


2. Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате "20.10.2017 8:10". Необходимо преобразовать поля к типу DATETIME, сохранив введеные ранее значения.

Сначала удалю таблицу users,
> drop tab
You're about to run a destructive command.
Do you want to proceed? (y/n): n
Wise choice!
> drop TABLE users
You're about to run a destructive command.
Do you want to proceed? (y/n): y
Your call!
Query OK, 0 rows affected
Time: 0.074s
> SHOW TABLES
+------------------+
| Tables_in_shop   |
|------------------|
+------------------+
0 rows in set
Time: 0.002s

Затем создам повторно, но заведемо неудачно спроектированную

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at VARCHAR(255),
  updated_at VARCHAR(255)
) COMMENT = 'Покупатели';

Добавлю строки cо значением "20.10.2017 8:10" тип VARCHAR

INSERT INTO users (name, birthday_at, created_at, updated_at) VALUES
  ('Геннадий', '1990-10-05', '20.10.2017 8:10', '20.10.2017 8:10'),
  ('Наталья', '1984-11-12','20.10.2017 8:10', '20.10.2017 8:10');

> select * from users
+------+----------+---------------+-----------------+-----------------+
|   id | name     | birthday_at   | created_at      | updated_at      |
|------+----------+---------------+-----------------+-----------------|
|    1 | Геннадий | 1990-10-05    | 20.10.2017 8:10 | 20.10.2017 8:10 |
|    2 | Наталья  | 1984-11-12    | 20.10.2017 8:10 | 20.10.2017 8:10 |
+------+----------+---------------+-----------------+-----------------+
2 rows in set
Time: 0.002s

Теперь нужно подготовить поля для изменения типа столбцов DATETIME

update users set created_at = str_to_date(created_at, '%d.%m.%Y %h:%i'), updated_at = str_to_date(updated_at, '%d.%m.%Y %h:%i')

Посмотрим, что получилось

> select * from users
+------+----------+---------------+---------------------+---------------------+
|   id | name     | birthday_at   | created_at          | updated_at          |
|------+----------+---------------+---------------------+---------------------|
|    1 | Геннадий | 1990-10-05    | 2017-10-20 08:10:00 | 2017-10-20 08:10:00 |
|    2 | Наталья  | 1984-11-12    | 2017-10-20 08:10:00 | 2017-10-20 08:10:00 |
+------+----------+---------------+---------------------+---------------------+
2 rows in set
Time: 0.002s
>

Alter table users modify column created_at datetime DEFAULT CURRENT_TIMESTAMP;
Alter table users modify column updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
 
Проверим, что типы поменялись
> DESC users
+-------------+---------------------+--------+-------+-------------------+-----------------------------------------------+
| Field       | Type                | Null   | Key   | Default           | Extra                                         |
|-------------+---------------------+--------+-------+-------------------+-----------------------------------------------|
| id          | bigint(20) unsigned | NO     | PRI   | <null>            | auto_increment                                |
| name        | varchar(255)        | YES    |       | <null>            |                                               |
| birthday_at | date                | YES    |       | <null>            |                                               |
| created_at  | datetime            | YES    |       | CURRENT_TIMESTAMP | DEFAULT_GENERATED                             |
| updated_at  | datetime            | YES    |       | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
+-------------+---------------------+--------+-------+-------------------+-----------------------------------------------+
5 rows in set
Time: 0.003s
 

3. В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры: 0, если товар закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения значения value.Однако, нулевые запасы должны выводиться в конце, после всех записей.

Создади таблицу
 
CREATE TABLE storehouses_products (
  id SERIAL PRIMARY KEY,
  storehouse_id INT UNSIGNED,
  product_id INT UNSIGNED,
  value INT UNSIGNED COMMENT 'Запас товарной позиции на складе',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Запасы на складе';

Добавим рандомные значения 

INSERT INTO `storehouses_products` VALUES ('1','3','8','0','1986-07-13 02:25:44','1976-01-23 00:05:01'),
('2','8','4','1940','1992-07-30 01:02:33','2002-07-07 06:51:50'),
('3','4','0','66','1985-08-30 10:40:43','1977-10-20 05:33:43'),
('4','2','9','0','1997-06-15 11:57:35','2003-05-10 03:56:18'),
('5','5','5','2369','2006-11-10 06:06:31','1983-10-04 03:12:42'),
('6','5','2','2476','2002-12-07 13:40:08','2001-10-11 06:33:24'),
('7','9','9','0','2005-07-30 13:22:16','1989-10-27 05:58:45'),
('8','2','3','1686','1986-11-02 18:23:18','1986-07-29 19:05:46'),
('9','4','6','2339','2006-02-27 02:08:02','1975-03-13 10:50:55'),
('10','2','2','1590','1992-10-26 20:42:00','1980-07-17 02:52:01');

> select * from storehouses_products;
+------+-----------------+--------------+---------+---------------------+---------------------+
|   id |   storehouse_id |   product_id |   value | created_at          | updated_at          |
|------+-----------------+--------------+---------+---------------------+---------------------|
|    1 |               3 |            8 |       0 | 1986-07-13 02:25:44 | 1976-01-23 00:05:01 |
|    2 |               8 |            4 |    1940 | 1992-07-30 01:02:33 | 2002-07-07 06:51:50 |
|    3 |               4 |            0 |      66 | 1985-08-30 10:40:43 | 1977-10-20 05:33:43 |
|    4 |               2 |            9 |       0 | 1997-06-15 11:57:35 | 2003-05-10 03:56:18 |
|    5 |               5 |            5 |    2369 | 2006-11-10 06:06:31 | 1983-10-04 03:12:42 |
|    6 |               5 |            2 |    2476 | 2002-12-07 13:40:08 | 2001-10-11 06:33:24 |
|    7 |               9 |            9 |       0 | 2005-07-30 13:22:16 | 1989-10-27 05:58:45 |
|    8 |               2 |            3 |    1686 | 1986-11-02 18:23:18 | 1986-07-29 19:05:46 |
|    9 |               4 |            6 |    2339 | 2006-02-27 02:08:02 | 1975-03-13 10:50:55 |
|   10 |               2 |            2 |    1590 | 1992-10-26 20:42:00 | 1980-07-17 02:52:01 |
+------+-----------------+--------------+---------+---------------------+---------------------+
10 rows in set
Time: 0.003s
>

Сделаю сортировку по полю value
select * from storehouses_products order by value=0, value

> select * from storehouses_products order by value=0, value
+------+-----------------+--------------+---------+---------------------+---------------------+
|   id |   storehouse_id |   product_id |   value | created_at          | updated_at          |
|------+-----------------+--------------+---------+---------------------+---------------------|
|    3 |               4 |            0 |      66 | 1985-08-30 10:40:43 | 1977-10-20 05:33:43 |
|   10 |               2 |            2 |    1590 | 1992-10-26 20:42:00 | 1980-07-17 02:52:01 |
|    8 |               2 |            3 |    1686 | 1986-11-02 18:23:18 | 1986-07-29 19:05:46 |
|    2 |               8 |            4 |    1940 | 1992-07-30 01:02:33 | 2002-07-07 06:51:50 |
|    9 |               4 |            6 |    2339 | 2006-02-27 02:08:02 | 1975-03-13 10:50:55 |
|    5 |               5 |            5 |    2369 | 2006-11-10 06:06:31 | 1983-10-04 03:12:42 |
|    6 |               5 |            2 |    2476 | 2002-12-07 13:40:08 | 2001-10-11 06:33:24 |
|    1 |               3 |            8 |       0 | 1986-07-13 02:25:44 | 1976-01-23 00:05:01 |
|    4 |               2 |            9 |       0 | 1997-06-15 11:57:35 | 2003-05-10 03:56:18 |
|    7 |               9 |            9 |       0 | 2005-07-30 13:22:16 | 1989-10-27 05:58:45 |
+------+-----------------+--------------+---------+---------------------+---------------------+

4. (по желанию) Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае. Месяцы заданы в виде списка английских названий ('may', 'august')

SELECT * from users where date_format(birthday_at, '%M') regexp '[mM]ay|[aA]ugust';
   
   
> SELECT *, date_format(birthday_at, '%M') as mount_birthday from users where date_format(birthday_at, '%M') regexp '[mM]ay|[aA]ugust'
                        ->
+------+-----------+---------------+---------------------+---------------------+------------------+
|   id | name      | birthday_at   | created_at          | updated_at          | mount_birthday   |
|------+-----------+---------------+---------------------+---------------------+------------------|
|    5 | Александр | 1985-05-20    | 2019-09-22 13:49:31 | 2019-09-22 13:49:31 | May              |
|    8 | Мария     | 1992-08-29    | 2019-09-22 13:49:31 | 2019-09-22 13:49:31 | August           |
+------+-----------+---------------+---------------------+---------------------+------------------+
2 rows in set
Time: 0.002s

5. (по желанию) Из таблицы catalogs извлекаются записи при помощи запроса. SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, заданном в списке IN.

Создадим таблицу 

DROP TABLE IF EXISTS catalogs;
CREATE TABLE catalogs (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Название раздела',
  UNIQUE unique_name(name(10))
) COMMENT = 'Разделы интернет-магазина';

Добавим строки

INSERT INTO catalogs VALUES
  (NULL, 'Процессоры'),
  (NULL, 'Материнские платы'),
  (NULL, 'Видеокарты'),
  (NULL, 'Жесткие диски'),
  (NULL, 'Оперативная память');

Проверим, что есть данные 

> select * from catalogs
+------+--------------------+
|   id | name               |
|------+--------------------|
|    1 | Процессоры         |
|    2 | Материнские платы  |
|    3 | Видеокарты         |
|    4 | Жесткие диски      |
|    5 | Оперативная память |
+------+--------------------+

Выполним выборку + сортирвку 

> select * from catalogs where id in (5,1,2) ORDER BY id=2,id=1,id=5
+------+--------------------+
|   id | name               |
|------+--------------------|
|    5 | Оперативная память |
|    1 | Процессоры         |
|    2 | Материнские платы  |
+------+--------------------+

или так

> select * from catalogs where id in (5,1,2) ORDER BY id=5 desc ,id=1 desc ,id=2 desc
+------+--------------------+
|   id | name               |
|------+--------------------|
|    5 | Оперативная память |
|    1 | Процессоры         |
|    2 | Материнские платы  |
+------+--------------------+
3 rows in set
Time: 0.002s

Практическое задание теме “Агрегация данных”

1. Подсчитайте средний возраст пользователей в таблице users

> select round(AVG(year(now()) - year(birthday_at))) avg_year  from users
+------------+
|   avg_year |
|------------|
|         30 |
+------------+
1 row in set

2. Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. Следует учесть, что необходимы дни недели текущего года, а не года рождения.

> select COUNT(1), day(birthday_at) days_b from users group by days_b
+------------+----------+
|   COUNT(1) |   days_b |
|------------+----------|
|          2 |        5 |
|          3 |       12 |
|          1 |       20 |
|          1 |       14 |
|          1 |       29 |
+------------+----------+


3. Подсчитайте произведение чисел в столбце таблицы

Сначала сделаю таблицу

mysql root@localhost:shop> create table tbl_num as select 1 num UNION select 2 UNION select 3 UNION select 4 union select 5
Query OK, 5 rows affected
Time: 0.122s
mysql root@localhost:shop> SELECT * from tbl_num
+-------+
|   num |
|-------|
|     1 |
|     2 |
|     3 |
|     4 |
|     5 |
+-------+

Посчитаем произвдение, через сумму натуральных логарифмов 

> SELECT EXP(SUM(LOG(num))) multi FROM tbl_num
+---------+
|   multi |
|---------|
|     120 |
+---------+






